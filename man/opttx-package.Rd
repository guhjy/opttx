% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/opttx-package.R
\docType{package}
\name{opttx-package}
\alias{opttx}
\alias{opttx-package}
\title{opttx - Optimal Treatment Estimation}
\description{
opttx - Optimal Treatment Estimation
}
\details{
\tabular{ll}{
Package: \tab origami\cr
Type: \tab Package\cr
Version: \tab 0.5\cr
Date: \tab 2014-08-17\cr
License: \tab GPL-3\cr
LazyLoad: \tab yes\cr

}

opttx estimates optimal treatment rules and the mean outcome under such rules
}
\examples{
Qbar0 <- function(A, W) {
    
    W1 <- W[, 1]
    W2 <- W[, 2]
    W3 <- W[, 3]
    W4 <- W[, 4]
    Qbar <- plogis(ifelse(W4 > 0, (A == 1) + (A == 1) * (5 * W1^2 - 4.45), (A == 
        2) + (A == 3) + (A == 2) * (4 * W2) + (A == 3) * (5 * W3)))
    return(Qbar)
}

g0 <- function(W) {
    W1 <- W[, 1]
    W2 <- W[, 2]
    W3 <- W[, 3]
    W4 <- W[, 4]
    
    # rep(0.5, nrow(W))
    A1 <- plogis(W1)
    A2 <- plogis(W2)
    A3 <- plogis(W3)
    A <- cbind(A1, A2, A3)
    
    # make sure A sums to 1
    A <- normalize_rows(A)
}

gen_data <- function(n = 1000, p = 4) {
    W <- matrix(rnorm(n * p), nrow = n)
    colnames(W) <- paste("W", seq_len(p), sep = "")
    pA <- g0(W)
    A <- factor(apply(pA, 1, function(pAi) which(rmultinom(1, 1, pAi) == 1)))
    A_vals <- vals_from_factor(A)
    
    u <- runif(n)
    Y <- as.numeric(u < Qbar0(A, W))
    Q0aW <- sapply(A_vals, Qbar0, W)
    d0 <- max.col(Q0aW)
    Yd0 <- as.numeric(u < Qbar0(d0, W))
    data.frame(W, A, Y, Q0aW, d0, Yd0)
}

testdata <- gen_data(1e+05, 5)


opt_tmle.SL.library <- list(Q = c("SL.glm", "SL.glmem", "SL.glmnetprob", "SL.step.forward", 
    "SL.gam", "SL.rpart", "SL.rpartPrune", "SL.mean"), g = c("mnSL.randomForest", 
    "mnSL.glmnet", "mnSL.multinom", "mnSL.mean"), QaV = c("SL.glm", "SL.glmnetprob", 
    "SL.step.forward", "SL.gam", "SL.rpart", "SL.rpartPrune", "SL.mean"), class = c())

sim <- function(iteration) {
    data <- gen_data(1000, 5)
    result <- opt_tmle(data, SL.library = opt_tmle.SL.library)
    Wnodes <- result$nodes$Wnodes
    
    QaV_dV <- predict(other_fit, newdata = testdata[, Wnodes], pred_fit = "QaV")
    QaV_perf <- mean(Qbar0(QaV_dV, testdata[, Wnodes]))
    EYd_dV <- predict(other_fit, newdata = testdata[, Wnodes], pred_fit = "joint")
    EYd_perf <- mean(Qbar0(EYd_dV, testdata[, Wnodes]))
    perf <- data.frame(blip_type, EYd_perf, QaV_perf)
    
    other_blips <- c("blip1", "blip2", "blip3")
    other_perf <- ldply(other_blips, function(blip_type) {
        other_fit <- with(result, learn_rule(data, folds, nodes, split_preds, val_preds, 
            parallel = F, SL.library = SL.library, verbose, blip_type = blip_type))
        QaV_dV <- predict(other_fit, newdata = testdata[, Wnodes], pred_fit = "QaV")
        QaV_perf <- mean(Qbar0(QaV_dV, testdata[, Wnodes]))
        EYd_dV <- predict(other_fit, newdata = testdata[, Wnodes], pred_fit = "joint")
        EYd_perf <- mean(Qbar0(EYd_dV, testdata[, Wnodes]))
        data.frame(blip_type, EYd_perf, QaV_perf)
    })
}
mean(Qbar0(testdata$d0, testdata[, Wnodes]))
# perf of true blip approx=0.758

print(result)
plot(result)

vim <- tx_vim(result)
ggplot(vim, aes(y = node, x = risk_full_fraction, color = model)) + geom_point() + 
    theme_bw() + xlab("VIM")

library(reshape2)
long <- melt(vim, id = c("node", "model"))
ggplot(long, aes(y = node, x = value, color = model)) + geom_point() + facet_wrap(~variable, 
    scales = "free") + theme_bw() 
}
\author{
Jeremy Coyle \email{jeremyrcoyle@gmail.com}
}
\seealso{
\code{\link{cross_validate}}, \code{\link{origami_SuperLearner}}
}
\keyword{package}

